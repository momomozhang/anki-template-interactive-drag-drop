<p id="header1-field" style="display:none;">{{Header1}}</p>
<p id="header2-field" style="display:none;">{{Header2}}</p>
<p id="header3-field" style="display:none;">{{Header3}}</p>
<p id="header4-field" style="display:none;">{{Header4}}</p>
<p id="header5-field" style="display:none;">{{Header5}}</p>
<p id="header6-field" style="display:none;">{{Header6}}</p>
<p id="header7-field" style="display:none;">{{Header7}}</p>

<p id="terms1-field" style="display:none;">{{Terms1}}</p>
<p id="terms2-field" style="display:none;">{{Terms2}}</p>
<p id="terms3-field" style="display:none;">{{Terms3}}</p>
<p id="terms4-field" style="display:none;">{{Terms4}}</p>
<p id="terms5-field" style="display:none;">{{Terms5}}</p>
<p id="terms6-field" style="display:none;">{{Terms6}}</p>
<p id="terms7-field" style="display:none;">{{Terms7}}</p>

<p id="layout-field" style="display:none;">{{Layout}}</p>

<div class="game-container">
    <h1>{{Title}}</h1>

    <!-- Tables will be created dynamically via JavaScript -->
    <div id="dynamic-table"></div>

    <div id="terms-container"></div>
    <div id="checkButton" class="button-like">Check Answers</div>
    <div id="resetButton" class="button-like" style="display:none;">Reset</div>
</div>

<script>
// anki-persistence library
if (typeof(window.Persistence) === 'undefined') {
    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';
    var _defaultKey = '_default';
    window.Persistence_sessionStorage = function() {
        var isAvailable = false;
        try {
            if (typeof(window.sessionStorage) === 'object') {
                isAvailable = true;
                this.clear = function() {
                    for (var i = 0; i < sessionStorage.length; i++) {
                        var k = sessionStorage.key(i);
                        if (k.indexOf(_persistenceKey) == 0) {
                            sessionStorage.removeItem(k);
                            i--;
                        }
                    }
                };
                this.setItem = function(key, value) {
                    if (value == undefined) {
                        value = key;
                        key = _defaultKey;
                    }
                    sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));
                };
                this.getItem = function(key) {
                    if (key == undefined) {
                        key = _defaultKey;
                    }
                    return JSON.parse(sessionStorage.getItem(_persistenceKey + key));
                };
                this.removeItem = function(key) {
                    if (key == undefined) {
                        key = _defaultKey;
                    }
                    sessionStorage.removeItem(_persistenceKey + key);
                };
            }
        } catch(err) {}
        this.isAvailable = function() {
            return isAvailable;
        };
    };
    window.Persistence_windowKey = function(key) {
        var isAvailable = false;
        try {
            if (typeof(window[key]) === 'object') {
                isAvailable = true;
                this.clear = function() {
                    window[key] = {};
                };
                this.setItem = function(key, value) {
                    if (value == undefined) {
                        value = key;
                        key = _defaultKey;
                    }
                    window[key][_persistenceKey + key] = value;
                };
                this.getItem = function(key) {
                    if (key == undefined) {
                        key = _defaultKey;
                    }
                    return window[key][_persistenceKey + key];
                };
                this.removeItem = function(key) {
                    if (key == undefined) {
                        key = _defaultKey;
                    }
                    delete window[key][_persistenceKey + key];
                };
            }
        } catch(err) {}
        this.isAvailable = function() {
            return isAvailable;
        };
    };
    window.Persistence = new Persistence_sessionStorage();
    if (!window.Persistence.isAvailable()) {
        window.Persistence = new Persistence_windowKey(window.location.href);
        if (!window.Persistence.isAvailable()) {
            window.Persistence = new Persistence_windowKey('anki-persistence');
        }
    }
}

    function run() {
        // Always clear state at the beginning of front side to prevent persistence issues
        if (window.Persistence && window.Persistence.isAvailable()) {
            // Only clear if this is truly a fresh front side load (not back side)
            const isBackSide = window.Persistence.getItem('showSolution');
            if (!isBackSide) {
                window.Persistence.clear();
            }
        }
        
        const layout = document.getElementById("layout-field").innerText.trim().toUpperCase();

        const headers = [
            document.getElementById("header1-field").innerText,
            document.getElementById("header2-field").innerText,
            document.getElementById("header3-field").innerText,
            document.getElementById("header4-field").innerText,
            document.getElementById("header5-field").innerText,
            document.getElementById("header6-field").innerText,
            document.getElementById("header7-field").innerText
        ];

        const terms = [
            document.getElementById("terms1-field").innerText.split("|"),
            document.getElementById("terms2-field").innerText.split("|"),
            document.getElementById("terms3-field").innerText.split("|"),
            document.getElementById("terms4-field").innerText.split("|"),
            document.getElementById("terms5-field").innerText.split("|"),
            document.getElementById("terms6-field").innerText.split("|"),
            document.getElementById("terms7-field").innerText.split("|")
        ];

        // Filter headers and terms that are blank
        const validHeaders = headers.filter((header, index) => header.trim() !== "" && terms[index].length > 0);
        const validTerms = terms.filter((termList, index) => headers[index].trim() !== "" && termList.length > 0);

        let allTerms = validTerms.flat(); // All terms to shuffle

        // Create table dynamically based on layout and valid headers
        const dynamicTable = document.getElementById("dynamic-table");
        dynamicTable.innerHTML = generateTable(layout, validHeaders);

        const termsContainer = document.getElementById("terms-container");

        function initializeGame(layoutParam, validTermsParam, allTermsParam, termsContainerParam) {
            clearTable();
            
            // Check if we should show solution (back side)
            const isBackSide = window.Persistence && window.Persistence.isAvailable() && window.Persistence.getItem('showSolution');
            
            if (isBackSide) {
                // Solution mode - display correct answers
                showSolution(layoutParam, validTermsParam);
                
                // Hide interactive elements
                if (termsContainerParam) termsContainerParam.style.display = 'none';
                const checkButton = document.getElementById("checkButton");
                if (checkButton) checkButton.style.display = 'none';
                const resetButton = document.getElementById("resetButton");
                if (resetButton) resetButton.style.display = 'none';
                return;
            }
            
            // Original game logic
            allTermsParam = allTermsParam.sort(() => Math.random() - 0.5);
            termsContainerParam.innerHTML = allTermsParam.map(term => `<div class="term draggable" draggable="true">${term}</div>`).join('');

            const draggableItems = document.querySelectorAll('.draggable');
            draggableItems.forEach(item => {
                item.addEventListener('dragstart', dragStart);
                item.addEventListener('dragend', dragEnd);
            });

            const dropzones = document.querySelectorAll('.dropzone');
            dropzones.forEach(zone => {
                zone.addEventListener('dragover', dragOver);
                zone.addEventListener('drop', drop);
            });

            document.getElementById("resetButton").style.display = 'none';
        }
        
        function showSolution(layoutParam, validTermsParam) {
            validTermsParam.forEach((categoryTerms, index) => {
                const dropzoneId = layoutParam === 'V' ? `col${index + 1}-vert` : `col${index + 1}`;
                const dropzone = document.getElementById(dropzoneId);
                
                if (dropzone) {
                    categoryTerms.forEach(termString => {
                        const terms = termString.split('|').map(t => t.trim());
                        terms.forEach(term => {
                            if (term) {
                                dropzone.innerHTML += `<div class="term correct">${term}<div class="question-plus-one"></div></div>`;
                            }
                        });
                    });
                }
            });
        }

        function clearTable() {
            const dropzones = document.querySelectorAll('.dropzone');
            dropzones.forEach(zone => {
                zone.innerHTML = ''; // Clear all terms inside the drop zones
                zone.classList.remove('correct', 'incorrect'); // Remove the style classes
            });
        }

        function dragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.innerText);
            setTimeout(() => e.target.classList.add('hide'), 0);
        }

        function dragEnd(e) {
            setTimeout(() => {
                e.target.classList.remove('hide');
            }, 0);
        }

        function dragOver(e) {
            e.preventDefault();
        }

        function drop(e) {
            e.preventDefault();
            const term = e.dataTransfer.getData('text/plain');
            const targetZone = e.target;

            if (targetZone.classList.contains('dropzone') || targetZone.classList.contains('term')) {
                if (targetZone.classList.contains('term')) {
                    targetZone.parentElement.innerHTML += `<div class="term draggable" draggable="true">${term}</div>`;
                } else {
                    targetZone.innerHTML += `<div class="term draggable" draggable="true">${term}</div>`;
                }

                const draggedItem = document.querySelector(`.draggable.hide`);
                if (draggedItem) draggedItem.remove();

                reattachDragEvents();
            } else {
                const draggedItem = document.querySelector(`.draggable.hide`);
                if (draggedItem) {
                    draggedItem.classList.remove('hide');
                }
            }
        }

        function reattachDragEvents() {
            const draggableItems = document.querySelectorAll('.draggable');
            draggableItems.forEach(item => {
                item.removeEventListener('dragstart', dragStart);
                item.removeEventListener('dragend', dragEnd);
                item.addEventListener('dragstart', dragStart);
                item.addEventListener('dragend', dragEnd);
            });
        }

        document.getElementById("checkButton").addEventListener('click', checkAnswers);
        document.getElementById("resetButton").addEventListener('click', () => initializeGame(layout, validTerms, allTerms, termsContainer));

        function checkAnswers() {
            const dropzones = document.querySelectorAll('.dropzone');

            // Check the terms in the boxes (dropzones)
            dropzones.forEach((zone, index) => {
                const termsInZone = Array.from(zone.getElementsByClassName('term'));
                const expectedTerms = validTerms[index]; // Use only valid terms

                termsInZone.forEach(termElement => {
                    const term = termElement.innerText.trim(); // Remove unnecessary spaces around the term
                    let isCorrect = false;

                    // Check if the complete term is equal or if it's part of terms separated by |
                    expectedTerms.forEach(expectedTerm => {
                        // Remove spaces around each term, but keep internal spaces
                        const possibleAnswers = expectedTerm.split('|').map(t => t.trim()); // Use trim() for each term
                        if (possibleAnswers.includes(term)) {
                            isCorrect = true;
                        }
                    });

                    // Remove previous icons
                    termElement.querySelectorAll('.question-plus-one, .question-minus-one, .correct-answer-hint').forEach(icon => icon.remove());

                    if (isCorrect) {
                        termElement.classList.add('correct');
                        termElement.classList.remove('incorrect');
                        // Add +1 icon
                        termElement.insertAdjacentHTML('beforeend', '<div class="question-plus-one"></div>');
                    } else {
                        termElement.classList.add('incorrect');
                        termElement.classList.remove('correct');
                        // Add -1 icon
                        termElement.insertAdjacentHTML('beforeend', '<div class="question-minus-one"></div>');
                        // Find and show correct category
                        const correctCategory = findCorrectCategory(term, validTerms, validHeaders);
                        if (correctCategory) {
                            termElement.insertAdjacentHTML('beforeend', `<div class="correct-answer-hint">${correctCategory}</div>`);
                        }
                    }
                });
            });

            // Check terms that were not associated with any box (forgotten)
            const remainingTerms = document.querySelectorAll('#terms-container .term');
            remainingTerms.forEach(termElement => {
                // Mark as incorrect (were forgotten)
                termElement.classList.add('incorrect');
                termElement.classList.remove('correct');
                // Remove previous icons
                termElement.querySelectorAll('.question-plus-one, .question-minus-one, .correct-answer-hint').forEach(icon => icon.remove());
                // Add -1 icon
                termElement.insertAdjacentHTML('beforeend', '<div class="question-minus-one"></div>');
                // Find and show correct category for forgotten terms
                const term = termElement.innerText.trim();
                const correctCategory = findCorrectCategory(term, validTerms, validHeaders);
                if (correctCategory) {
                    termElement.insertAdjacentHTML('beforeend', `<div class="correct-answer-hint">${correctCategory}</div>`);
                }
            });

            document.getElementById("resetButton").style.display = 'block';
        }

        initializeGame(layout, validTerms, allTerms, termsContainer);
    }

    function findCorrectCategory(term, validTerms, validHeaders) {
        
        for (let i = 0; i < validTerms.length; i++) {
            const categoryTerms = validTerms[i];
            // Handle the case where categoryTerms is an array of terms
            for (let j = 0; j < categoryTerms.length; j++) {
                const currentTerm = categoryTerms[j];
                // Handle multiple answers separated by |
                const possibleAnswers = currentTerm.split('|').map(t => t.trim());
                
                if (possibleAnswers.includes(term.trim())) {
                    return validHeaders[i];
                }
            }
        }
        return null;
    }

    function generateTable(layout, headers) {
        let tableHTML = '';
        if (layout === 'V') {
            // Vertical layout
            tableHTML = `<table><thead><tr><th></th><th>Terms</th></tr></thead><tbody>`;
            headers.forEach((header, index) => {
                tableHTML += `<tr><th>${header}</th><td id="col${index + 1}-vert" class="dropzone"></td></tr>`;
            });
            tableHTML += `</tbody></table>`;
        } else {
            // Horizontal layout
            tableHTML = `<table><thead><tr>`;
            headers.forEach((header, index) => {
                tableHTML += `<th id="header${index + 1}">${header}</th>`;
            });
            tableHTML += `</tr></thead><tbody><tr>`;
            headers.forEach((header, index) => {
                tableHTML += `<td id="col${index + 1}" class="dropzone"></td>`;
            });
            tableHTML += `</tr></tbody></table>`;
        }
        return tableHTML;
    }

    run();
</script>